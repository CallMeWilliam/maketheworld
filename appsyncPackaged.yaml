AWSTemplateFormatVersion: '2010-09-09'
Transform: AWS::Serverless-2016-10-31
Description: 'burnedover-mush-appsync-api

  SAM Template for the AppSync API for burnedover-mush

  '
Parameters:
  TablePrefix:
    Type: String
    Default: burnedoverdev
    Description: (Required) The name of the new DynamoDB to store connection identifiers
      for each connected clients. Minimum 3 characters
    MinLength: 3
    MaxLength: 50
    AllowedPattern: ^[A-Za-z_]+$
    ConstraintDescription: Required. Can be characters and underscore only. No numbers
      or special characters allowed.
  PermanentsStack:
    Type: String
    Default: BurnedOverDevPermanentsStack
    Description: (Required) The name of the stack containing the permanents DynamoDB
      table.
    MinLength: 3
    MaxLength: 50
    AllowedPattern: ^[A-Za-z_]+$
    ConstraintDescription: Required. Can be characters and underscore only. No numbers
      or special characters allowed.
  UserPoolId:
    Type: String
    Default: us-east-1_legdibKxO
    Description: The physical ID of the cognito user pool that the API should validate
      against.
Resources:
  AppSyncAPI:
    Type: AWS::AppSync::GraphQLApi
    Properties:
      Name:
        Fn::Sub: ${TablePrefix}AppSyncAPI
      AuthenticationType: AMAZON_COGNITO_USER_POOLS
      UserPoolConfig:
        AwsRegion: us-east-1
        UserPoolId:
          Ref: UserPoolId
        DefaultAction: ALLOW
  AppSyncAPIExecutionRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Statement:
        - Effect: Allow
          Principal:
            Service: appsync.amazonaws.com
          Action:
          - sts:AssumeRole
      Policies:
      - PolicyName: CharactersPolicy
        PolicyDocument:
          Version: '2012-10-17'
          Statement:
          - Effect: Allow
            Action:
            - dynamodb:GetItem
            - dynamodb:BatchGetItem
            - dynamodb:Query
            - dynamodb:PutItem
            Resource:
              Fn::Sub: arn:aws:dynamodb:*:*:table/${TablePrefix}_characters
      - PolicyName: CharacterIndexPolicy
        PolicyDocument:
          Version: '2012-10-17'
          Statement:
          - Effect: Allow
            Action:
            - dynamodb:Query
            Resource:
              Fn::Sub: arn:aws:dynamodb:*:*:table/${TablePrefix}_characters/*
      - PolicyName: CharactersInPlayPolicy
        PolicyDocument:
          Version: '2012-10-17'
          Statement:
          - Effect: Allow
            Action:
            - dynamodb:GetItem
            - dynamodb:BatchGetItem
            - dynamodb:Query
            - dynamodb:PutItem
            - dynamodb:UpdateItem
            - dynamodb:Scan
            Resource:
              Fn::Sub: arn:aws:dynamodb:*:*:table/${TablePrefix}_characters_in_play
      - PolicyName: PermanentsPolicy
        PolicyDocument:
          Version: '2012-10-17'
          Statement:
          - Effect: Allow
            Action:
            - dynamodb:GetItem
            - dynamodb:BatchGetItem
            - dynamodb:Query
            - dynamodb:PutItem
            - dynamodb:UpdateItem
            - dynamodb:Scan
            Resource:
              Fn::Sub: arn:aws:dynamodb:*:*:table/${TablePrefix}_permanents
      - PolicyName: PermanentsIndexPolicy
        PolicyDocument:
          Version: '2012-10-17'
          Statement:
          - Effect: Allow
            Action:
            - dynamodb:Query
            Resource:
              Fn::Sub: arn:aws:dynamodb:*:*:table/${TablePrefix}_permanents/*
      - PolicyName: PutRoomPathsPolicy
        PolicyDocument:
          Version: '2012-10-17'
          Statement:
          - Effect: Allow
            Action:
            - lambda:InvokeFunction
            Resource:
              Fn::GetAtt:
              - PutRoomPathsFunction
              - Arn
  CharacterDynamoDBTableDataSource:
    Type: AWS::AppSync::DataSource
    Properties:
      ApiId:
        Fn::GetAtt:
        - AppSyncAPI
        - ApiId
      Name: Character
      Type: AMAZON_DYNAMODB
      ServiceRoleArn:
        Fn::GetAtt:
        - AppSyncAPIExecutionRole
        - Arn
      DynamoDBConfig:
        AwsRegion: us-east-1
        TableName:
          Fn::Sub: ${TablePrefix}_characters
  CharactersInPlayDynamoDBTableDataSource:
    Type: AWS::AppSync::DataSource
    Properties:
      ApiId:
        Fn::GetAtt:
        - AppSyncAPI
        - ApiId
      Name: CharactersInPlay
      Type: AMAZON_DYNAMODB
      ServiceRoleArn:
        Fn::GetAtt:
        - AppSyncAPIExecutionRole
        - Arn
      DynamoDBConfig:
        AwsRegion: us-east-1
        TableName:
          Fn::Sub: ${TablePrefix}_characters_in_play
  PermanentsDynamoDBTableDataSource:
    Type: AWS::AppSync::DataSource
    Properties:
      ApiId:
        Fn::GetAtt:
        - AppSyncAPI
        - ApiId
      Name: Permanents
      Type: AMAZON_DYNAMODB
      ServiceRoleArn:
        Fn::GetAtt:
        - AppSyncAPIExecutionRole
        - Arn
      DynamoDBConfig:
        AwsRegion: us-east-1
        TableName:
          Fn::Sub: ${TablePrefix}_permanents
  QueryGetCharacterResolver:
    Type: AWS::AppSync::Resolver
    DependsOn: Schema
    Properties:
      ApiId:
        Fn::GetAtt:
        - AppSyncAPI
        - ApiId
      TypeName: Query
      FieldName: getCharacter
      DataSourceName:
        Fn::GetAtt:
        - CharacterDynamoDBTableDataSource
        - Name
      RequestMappingTemplate: "{\n    \"version\": \"2017-02-28\",\n    \"operation\"\
        : \"GetItem\",\n    \"key\": {\n        \"PlayerName\": $util.dynamodb.toDynamoDBJson($ctx.args.playerName),\n\
        \        \"Name\": $util.dynamodb.toDynamoDBJson($ctx.args.name)\n    }\n\
        }\n"
      ResponseMappingTemplate: $utils.toJson($ctx.result)
  QueryPlayerCharactersResolver:
    Type: AWS::AppSync::Resolver
    DependsOn: Schema
    Properties:
      ApiId:
        Fn::GetAtt:
        - AppSyncAPI
        - ApiId
      TypeName: Query
      FieldName: getPlayerCharacters
      DataSourceName:
        Fn::GetAtt:
        - CharacterDynamoDBTableDataSource
        - Name
      RequestMappingTemplate: "{\n    \"version\": \"2017-02-28\",\n    \"operation\"\
        : \"Query\",\n    \"query\": {\n        \"expression\": \"PlayerName = :PlayerName\"\
        ,\n        \"expressionValues\": {\n            \":PlayerName\": $util.dynamodb.toDynamoDBJson($context.identity.username)\n\
        \        }\n    }\n}\n"
      ResponseMappingTemplate: $utils.toJson($ctx.result.items)
  PutCharacterResolver:
    Type: AWS::AppSync::Resolver
    DependsOn: Schema
    Properties:
      ApiId:
        Fn::GetAtt:
        - AppSyncAPI
        - ApiId
      TypeName: Mutation
      FieldName: putCharacter
      DataSourceName:
        Fn::GetAtt:
        - CharacterDynamoDBTableDataSource
        - Name
      RequestMappingTemplate: "#if(!($ctx.args.CharacterId))\n    $util.qr($ctx.args.put(\"\
        CharacterId\", $util.autoId()))\n#end #set( $ddb = $util.dynamodb ) {\n  \
        \  \"version\": \"2017-02-28\",\n    \"operation\": \"PutItem\",\n    \"key\"\
        : {\n        \"PlayerName\": $ddb.toStringJson($context.identity.username),\n\
        \        \"Name\": $ddb.toStringJson($ctx.args.Name)\n    },\n    \"attributeValues\"\
        : {\n        \"CharacterId\": $ddb.toStringJson($ctx.args.CharacterId)\n \
        \       #if($ctx.args.Pronouns), \"Pronouns\": $ddb.toStringJson($ctx.args.Pronouns)\
        \ #end\n        #if($ctx.args.FirstImpression), \"FirstImpression\": $ddb.toStringJson($ctx.args.FirstImpression)\
        \ #end\n        #if($ctx.args.OneCoolThing), \"OneCoolThing\": $ddb.toStringJson($ctx.args.OneCoolThing)\
        \ #end\n        #if($ctx.args.Outfit), \"Outfit\": $ddb.toStringJson($ctx.args.Outfit)\
        \ #end\n    }\n}\n"
      ResponseMappingTemplate: $utils.toJson($ctx.result)
  CharacterInPlayGetCharacter:
    Type: AWS::AppSync::Resolver
    DependsOn: Schema
    Properties:
      ApiId:
        Fn::GetAtt:
        - AppSyncAPI
        - ApiId
      TypeName: CharacterInPlay
      FieldName: Character
      DataSourceName:
        Fn::GetAtt:
        - CharacterDynamoDBTableDataSource
        - Name
      RequestMappingTemplate: "{\n    \"version\": \"2017-02-28\",\n    \"operation\"\
        : \"GetItem\",\n    \"key\": {\n        \"PlayerName\": $util.dynamodb.toDynamoDBJson($context.source.PlayerName),\n\
        \        \"Name\": $util.dynamodb.toDynamoDBJson($context.source.Name)\n \
        \   }\n}\n"
      ResponseMappingTemplate: $utils.toJson($ctx.result)
  QueryGetCharactersInPlay:
    Type: AWS::AppSync::Resolver
    DependsOn: Schema
    Properties:
      ApiId:
        Fn::GetAtt:
        - AppSyncAPI
        - ApiId
      TypeName: Query
      FieldName: getCharactersInPlay
      DataSourceName:
        Fn::GetAtt:
        - CharactersInPlayDynamoDBTableDataSource
        - Name
      RequestMappingTemplate: "{\n    \"version\": \"2017-02-28\",\n    \"operation\"\
        : \"Scan\",\n    \"filter\": {\n        \"expression\": \"attribute_exists(ConnectionId)\"\
        ,\n    }\n}\n"
      ResponseMappingTemplate: $utils.toJson($ctx.result.items)
  QueryGetNeighborhoodTree:
    Type: AWS::AppSync::Resolver
    Properties:
      ApiId:
        Fn::GetAtt:
        - AppSyncAPI
        - ApiId
      TypeName: Query
      FieldName: getNeighborhoodTree
      DataSourceName:
        Fn::GetAtt:
        - PermanentsDynamoDBTableDataSource
        - Name
      RequestMappingTemplate: "{\n    \"version\": \"2018-05-29\",\n    \"operation\"\
        : \"Scan\",\n    \"filter\": {\n        \"expression\": \"#t = :neighborhood\
        \ or #t = :room\",\n        \"expressionNames\": {\n            \"#t\": \"\
        type\"\n        },\n        \"expressionValues\": {\n            \":neighborhood\"\
        : $util.dynamodb.toStringJson(\"NEIGHBORHOOD\"),\n            \":room\": $util.dynamodb.toStringJson(\"\
        ROOM\")\n        }\n    }\n}\n"
      ResponseMappingTemplate: "#set($output = []) #foreach($node in $ctx.result.items)\n\
        \    #if($node.type == \"NEIGHBORHOOD\")\n        #set($typeName = \"Neighborhood\"\
        )\n    #else\n        #set($typeName = \"Room\")\n    #end\n    $util.qr($output.add({\n\
        \        \"__typename\": $typeName,\n        \"Name\": $node.name,\n     \
        \   \"Type\": $node.type,\n        \"PermanentId\": $node.permanentId,\n \
        \       \"ParentId\": $node.parentId,\n        \"Ancestry\": $node.ancestry\n\
        \    }))\n#end $util.toJson($output)\n"
  QueryGetNeighborhood:
    Type: AWS::AppSync::Resolver
    Properties:
      ApiId:
        Fn::GetAtt:
        - AppSyncAPI
        - ApiId
      TypeName: Query
      FieldName: getNeighborhood
      DataSourceName:
        Fn::GetAtt:
        - PermanentsDynamoDBTableDataSource
        - Name
      RequestMappingTemplate: "{\n    \"version\": \"2017-02-28\",\n    \"operation\"\
        : \"GetItem\",\n    \"key\": {\n        \"permanentId\": $util.dynamodb.toDynamoDBJson($ctx.args.PermanentId)\n\
        \    }\n}\n"
      ResponseMappingTemplate: "#if($ctx.result.type == \"NEIGHBORHOOD\")\n    {\n\
        \        \"PermanentId\": $util.toJson($ctx.result.permanentId),\n       \
        \ \"ParentId\": $util.toJson($ctx.result.parentId),\n        \"PermanentId\"\
        : $util.toJson($ctx.result.permanentId),\n        \"Name\": $util.toJson($ctx.result.name),\n\
        \        \"Type\": $util.toJson($ctx.result.type),\n        \"Ancestry\":\
        \ $util.toJson($ctx.result.ancestry),\n        \"Description\": $util.toJson($ctx.result.description)\n\
        \    }\n#else\n    $util.error(\"PermanentId must specify a NEIGHBORHOOD type\
        \ permanent\")\n#end\n"
  QueryGetRoom:
    Type: AWS::AppSync::Resolver
    Properties:
      ApiId:
        Fn::GetAtt:
        - AppSyncAPI
        - ApiId
      TypeName: Query
      FieldName: getRoom
      DataSourceName:
        Fn::GetAtt:
        - PermanentsDynamoDBTableDataSource
        - Name
      RequestMappingTemplate: "{\n    \"version\": \"2017-02-28\",\n    \"operation\"\
        : \"GetItem\",\n    \"key\": {\n        \"permanentId\": $util.dynamodb.toDynamoDBJson($ctx.args.PermanentId)\n\
        \    }\n}\n"
      ResponseMappingTemplate: "#if($ctx.result.type == \"ROOM\")\n    {\n       \
        \ \"PermanentId\": $util.toJson($ctx.result.permanentId),\n        \"ParentId\"\
        : $util.toJson($ctx.result.parentId),\n        \"PermanentId\": $util.toJson($ctx.result.permanentId),\n\
        \        \"Name\": $util.toJson($ctx.result.name),\n        \"Type\": $util.toJson($ctx.result.type),\n\
        \        \"Ancestry\": $util.toJson($ctx.result.ancestry),\n        \"Description\"\
        : $util.toJson($ctx.result.description)\n    }\n#else\n    $util.error(\"\
        PermanentId must specify a ROOM type permanent\")\n#end\n"
  QueryGetRoomExits:
    Type: AWS::AppSync::Resolver
    Properties:
      ApiId:
        Fn::GetAtt:
        - AppSyncAPI
        - ApiId
      TypeName: Room
      FieldName: Exits
      DataSourceName:
        Fn::GetAtt:
        - PermanentsDynamoDBTableDataSource
        - Name
      RequestMappingTemplate: "{\n    \"version\": \"2017-02-28\",\n    \"operation\"\
        : \"Query\",\n    \"query\": {\n        \"expression\": \"fromRoomId = :RoomId\"\
        ,\n        \"expressionValues\": {\n            \":RoomId\": $util.dynamodb.toDynamoDBJson($ctx.source.PermanentId)\n\
        \        }\n    },\n    \"index\": \"fromRoomIndex\"\n}\n"
      ResponseMappingTemplate: "[\n    #foreach($exit in $ctx.result.items)\n    \
        \    {\n            \"PermanentId\": $util.toJson($exit.permanentId),\n  \
        \          \"Name\": $util.toJson($exit.name),\n            \"RoomId\": $util.toJson($exit.parentId),\n\
        \            \"Ancestry\": $util.toJson($exit.ancestry)\n        }#if($foreach.hasNext),#end\n\
        \    #end\n]\n"
  QueryGetRoomEntries:
    Type: AWS::AppSync::Resolver
    Properties:
      ApiId:
        Fn::GetAtt:
        - AppSyncAPI
        - ApiId
      TypeName: Room
      FieldName: Entries
      DataSourceName:
        Fn::GetAtt:
        - PermanentsDynamoDBTableDataSource
        - Name
      RequestMappingTemplate: "{\n    \"version\": \"2017-02-28\",\n    \"operation\"\
        : \"Query\",\n    \"query\": {\n        \"expression\": \"parentId = :RoomId\"\
        ,\n        \"expressionValues\": {\n            \":RoomId\": $util.dynamodb.toDynamoDBJson($ctx.source.PermanentId)\n\
        \        }\n    },\n    \"index\": \"parentIndex\"\n}\n"
      ResponseMappingTemplate: "[\n    #foreach($entry in $ctx.result.items)\n   \
        \     {\n            \"PermanentId\": $util.toJson($entry.permanentId),\n\
        \            \"Name\": $util.toJson($entry.name),\n            \"RoomId\"\
        : $util.toJson($entry.fromRoomId),\n            \"Ancestry\": $util.toJson($entry.ancestry)\n\
        \        }#if($foreach.hasNext),#end\n    #end\n]\n"
  MutationPreQueryCharacterInPlay:
    Type: AWS::AppSync::FunctionConfiguration
    Properties:
      FunctionVersion: '2018-05-29'
      ApiId:
        Fn::GetAtt:
        - AppSyncAPI
        - ApiId
      Name: PreQueryCharacterInPlay
      Description: Checks before adding a character to see if a past record exists
        to reactivate
      DataSourceName:
        Fn::GetAtt:
        - CharactersInPlayDynamoDBTableDataSource
        - Name
      RequestMappingTemplate: "#if (!$ctx.prev.result.CharacterId)\n    $ctx.error(\"\
        CharacterId required\")\n#end {\n    \"version\": \"2017-02-28\",\n    \"\
        operation\": \"GetItem\",\n    \"key\": {\n        \"CharacterId\": $util.dynamodb.toDynamoDBJson($ctx.prev.result.CharacterId)\n\
        \    }\n}\n"
      ResponseMappingTemplate: "#if ($ctx.result.PlayerName)\n    {\n        \"CharacterId\"\
        : \"$ctx.prev.result.CharacterId\",\n        \"ConnectionId\": \"$ctx.prev.result.ConnectionId\"\
        ,\n        \"PlayerName\": \"$ctx.result.PlayerName\",\n        \"Name\":\
        \ \"$ctx.result.Name\",\n        \"RoomId\": \"$ctx.result.RoomId\",\n   \
        \     \"Reactivate\": true\n    }\n#else\n    {\n        \"CharacterId\":\
        \ \"$ctx.prev.result.CharacterId\",\n        \"ConnectionId\": \"$ctx.prev.result.ConnectionId\"\
        ,\n        \"Reactivate\": false\n    }\n#end\n"
  MutationPreQueryCharacterIfNeeded:
    Type: AWS::AppSync::FunctionConfiguration
    Properties:
      FunctionVersion: '2018-05-29'
      ApiId:
        Fn::GetAtt:
        - AppSyncAPI
        - ApiId
      Name: PreQueryCharacterIfNeeded
      Description: Checks if needed before adding a character to find PlayerName and
        Name
      DataSourceName:
        Fn::GetAtt:
        - CharacterDynamoDBTableDataSource
        - Name
      RequestMappingTemplate: "#if ($ctx.prev.result.Reactivate)\n    #return($ctx.prev.result)\n\
        #else {\n    \"version\": \"2017-02-28\",\n    \"operation\": \"Query\",\n\
        \    \"query\": {\n        \"expression\": \"CharacterId = :characterId\"\
        ,\n        \"expressionValues\": {\n            \":characterId\": $util.dynamodb.toStringJson($ctx.prev.result.CharacterId)\n\
        \        }\n    },\n    \"index\": \"CharacterIdIndex\"\n} #end\n"
      ResponseMappingTemplate: "#if ($ctx.error)\n    $util.error($ctx.error.message,\
        \ $ctx.error.type)\n#end #if ($ctx.result.Reactivate)\n    $util.toJson($ctx.result)\n\
        #else\n    #set($item = $ctx.result.items[0])\n    {\n        \"CharacterId\"\
        : \"$ctx.prev.result.CharacterId\",\n        \"ConnectionId\": \"$ctx.prev.result.ConnectionId\"\
        ,\n        \"PlayerName\": \"$item.PlayerName\",\n        \"Name\": \"$item.Name\"\
        ,\n        \"RoomId\": \"VORTEX\",\n        \"Reactivate\": false\n    }\n\
        #end\n"
  MutationAddCharacterInPlayPutFunction:
    Type: AWS::AppSync::FunctionConfiguration
    Properties:
      FunctionVersion: '2018-05-29'
      ApiId:
        Fn::GetAtt:
        - AppSyncAPI
        - ApiId
      Name: AddCharacterInPlay
      Description: Adds or activates a CharacterInPlay record
      DataSourceName:
        Fn::GetAtt:
        - CharactersInPlayDynamoDBTableDataSource
        - Name
      RequestMappingTemplate: "#set( $ddb = $util.dynamodb ) {\n    #if ($ctx.prev.result.Reactivate)\n\
        \        \"version\": \"2018-05-29\",\n        \"operation\": \"UpdateItem\"\
        ,\n        \"key\": {\n            \"CharacterId\": $ddb.toDynamoDBJson($ctx.prev.result.CharacterId)\n\
        \        },\n        \"update\": {\n            \"expression\": \"SET #connectionfield\
        \ = :connectionId\",\n            \"expressionNames\": {\n               \
        \ \"#connectionfield\": \"ConnectionId\"\n            },\n            \"expressionValues\"\
        : {\n                \":connectionId\": $ddb.toDynamoDBJson($ctx.prev.result.ConnectionId)\n\
        \            }\n        }\n    #else\n        \"version\" : \"2017-02-28\"\
        ,\n        \"operation\": \"PutItem\",\n        \"key\": {\n            \"\
        CharacterId\": $ddb.toDynamoDBJson($ctx.prev.result.CharacterId)\n       \
        \ },\n        \"attributeValues\": {\n            \"PlayerName\": $ddb.toDynamoDBJson($ctx.prev.result.PlayerName),\n\
        \            \"Name\": $ddb.toDynamoDBJson($ctx.prev.result.Name),\n     \
        \       \"RoomId\": $ddb.toDynamoDBJson($ctx.prev.result.RoomId),\n      \
        \      \"ConnectionId\": $ddb.toDynamoDBJson($ctx.prev.result.ConnectionId)\n\
        \        }\n    #end\n}\n"
      ResponseMappingTemplate: $utils.toJson($ctx.result)
  MutationAddCharacterInPlay:
    Type: AWS::AppSync::Resolver
    Properties:
      ApiId:
        Fn::GetAtt:
        - AppSyncAPI
        - ApiId
      TypeName: Mutation
      FieldName: addCharacterInPlay
      Kind: PIPELINE
      PipelineConfig:
        Functions:
        - Fn::GetAtt:
          - MutationPreQueryCharacterInPlay
          - FunctionId
        - Fn::GetAtt:
          - MutationPreQueryCharacterIfNeeded
          - FunctionId
        - Fn::GetAtt:
          - MutationAddCharacterInPlayPutFunction
          - FunctionId
      RequestMappingTemplate: "{\n    \"CharacterId\": $util.toJson($ctx.args.CharacterId),\n\
        \    \"ConnectionId\": $util.toJson($ctx.args.ConnectionId)\n}\n"
      ResponseMappingTemplate: $utils.toJson($ctx.result)
  MutationDeleteCharacterInPlayResolver:
    Type: AWS::AppSync::Resolver
    DependsOn: Schema
    Properties:
      ApiId:
        Fn::GetAtt:
        - AppSyncAPI
        - ApiId
      TypeName: Mutation
      FieldName: deleteCharacterInPlay
      DataSourceName:
        Fn::GetAtt:
        - CharactersInPlayDynamoDBTableDataSource
        - Name
      RequestMappingTemplate: "#if(!($ctx.args.CharacterId))\n    $util.error(\"CharacterId\
        \ field required\")\n#end #set( $ddb = $util.dynamodb ) {\n    \"version\"\
        : \"2018-05-29\",\n    \"operation\": \"UpdateItem\",\n    \"key\": {\n  \
        \      \"CharacterId\": $ddb.toDynamoDBJson($ctx.args.CharacterId)\n    },\n\
        \    \"update\": {\n        \"expression\": \"REMOVE #connectionfield\",\n\
        \        \"expressionNames\": {\n            \"#connectionfield\": \"ConnectionId\"\
        \n        }\n    }\n}\n"
      ResponseMappingTemplate: $utils.toJson($ctx.result)
  MutationMoveCharacterResolver:
    Type: AWS::AppSync::Resolver
    DependsOn: Schema
    Properties:
      ApiId:
        Fn::GetAtt:
        - AppSyncAPI
        - ApiId
      TypeName: Mutation
      FieldName: moveCharacter
      DataSourceName:
        Fn::GetAtt:
        - CharactersInPlayDynamoDBTableDataSource
        - Name
      RequestMappingTemplate: "#if(!($ctx.args.CharacterId))\n    $util.error(\"CharacterId\
        \ field required\")\n#end #set( $ddb = $util.dynamodb ) {\n    \"version\"\
        : \"2018-05-29\",\n    \"operation\": \"UpdateItem\",\n    \"key\": {\n  \
        \      \"CharacterId\": $ddb.toDynamoDBJson($ctx.args.CharacterId)\n    },\n\
        \    \"update\": {\n        \"expression\": \"SET #roomfield = :roomId\",\n\
        \        \"expressionNames\": {\n            \"#roomfield\": \"RoomId\"\n\
        \        },\n        \"expressionValues\": {\n            \":roomId\": $ddb.toDynamoDBJson($ctx.args.RoomId)\n\
        \        }\n    }\n}\n"
      ResponseMappingTemplate: $utils.toJson($ctx.result)
  MutationPreQueryPermanentParentFunction:
    Type: AWS::AppSync::FunctionConfiguration
    Properties:
      FunctionVersion: '2018-05-29'
      ApiId:
        Fn::GetAtt:
        - AppSyncAPI
        - ApiId
      Name: PreQueryPermanentParent
      Description: Gets the parent node in order to construct ancestry
      DataSourceName:
        Fn::GetAtt:
        - PermanentsDynamoDBTableDataSource
        - Name
      RequestMappingTemplate: "#if($ctx.prev.result.ParentId) {\n    \"version\":\
        \ \"2017-02-28\",\n    \"operation\": \"GetItem\",\n    \"key\": {\n     \
        \   \"permanentId\": $util.dynamodb.toStringJson($ctx.prev.result.ParentId)\n\
        \    }\n} #else\n    #return($ctx.prev.result)\n#end\n"
      ResponseMappingTemplate: "#if ($ctx.error)\n    $util.error($ctx.error.message,\
        \ $ctx.error.type)\n#end #set($prev = $ctx.prev.result) {\n    \"Name\": $util.toJson($prev.Name),\n\
        \    \"PermanentId\": $util.toJson($prev.PermanentId)\n    #if($prev.Description),\
        \ \"Description\": $util.toJson($prev.Description)#end\n    #if($prev.ParentId),\
        \ \"ParentId\": $util.toJson($prev.ParentId)#end\n    #if ($util.isMap($ctx.result))\n\
        \        #if ($ctx.result.ancestry)\n            , \"ParentAncestry\": $util.toJson($ctx.result.ancestry)\n\
        \        #end\n    #end    \n}\n"
  MutationPutNeighborhoodFunction:
    Type: AWS::AppSync::FunctionConfiguration
    Properties:
      FunctionVersion: '2018-05-29'
      ApiId:
        Fn::GetAtt:
        - AppSyncAPI
        - ApiId
      Name: PutNeighborhood
      Description: Puts a neighborhood into the Permanents table
      DataSourceName:
        Fn::GetAtt:
        - PermanentsDynamoDBTableDataSource
        - Name
      RequestMappingTemplate: "#set( $ddb = $util.dynamodb ) #set( $args = $ctx.prev.result\
        \ ) #set( $PermanentId = $args.PermanentId ) #if($util.isNullOrEmpty($PermanentId))\n\
        \    #set( $PermanentId = $util.autoId() )\n#end #if($args.ParentAncestry)\n\
        \    #set($ancestry = \"${args.ParentAncestry}:${PermanentId}\")\n#else\n\
        \    #set($ancestry = $PermanentId)\n#end {\n    \"version\": \"2017-02-28\"\
        ,\n    \"operation\": \"PutItem\",\n    \"key\": {\n        \"permanentId\"\
        : $ddb.toDynamoDBJson($PermanentId)\n    },\n    \"attributeValues\": {\n\
        \        \"name\": $ddb.toDynamoDBJson($args.Name),\n        \"type\": $ddb.toStringJson(\"\
        NEIGHBORHOOD\"),\n        \"ancestry\": $ddb.toStringJson($ancestry)\n   \
        \     #if($args.Description), \"description\": $ddb.toStringJson($args.Description)\
        \ #end\n        #if($args.ParentId), \"parentId\": $ddb.toStringJson($args.ParentId)\
        \ #end\n    }\n}\n"
      ResponseMappingTemplate: "{\n    \"PermanentId\": $util.toJson($ctx.result.permanentId),\n\
        \    \"ParentId\": $util.toJson($ctx.result.parentId),\n    \"Type\": \"NEIGHBORHOOD\"\
        ,\n    \"Ancestry\": $util.toJson($ctx.result.ancestry),\n    \"Name\": $util.toJson($ctx.result.name),\n\
        \    \"Description\": $util.toJson($ctx.result.description)\n}\n"
  MutationPutNeighborhood:
    Type: AWS::AppSync::Resolver
    Properties:
      ApiId:
        Fn::GetAtt:
        - AppSyncAPI
        - ApiId
      TypeName: Mutation
      FieldName: putNeighborhood
      Kind: PIPELINE
      PipelineConfig:
        Functions:
        - Fn::GetAtt:
          - MutationPreQueryPermanentParentFunction
          - FunctionId
        - Fn::GetAtt:
          - MutationPutNeighborhoodFunction
          - FunctionId
      RequestMappingTemplate: $utils.toJson($ctx.args)
      ResponseMappingTemplate: $utils.toJson($ctx.result)
  UUIDLambdaLayer:
    Type: AWS::Serverless::LayerVersion
    Properties:
      LayerName: uuid-layer
      Description: Lambda layer to import the uuid library
      ContentUri: s3://burned-over-mush-development/686cf8ad286bd1064146ad5a56565d03
      CompatibleRuntimes:
      - nodejs12.x
  PutRoomPathsFunction:
    Type: AWS::Serverless::Function
    Properties:
      CodeUri: s3://burned-over-mush-development/3d451e0d973068ada42f251b1c50ff6a
      Handler: app.handler
      MemorySize: 256
      Runtime: nodejs12.x
      Layers:
      - Ref: UUIDLambdaLayer
      Environment:
        Variables:
          TABLE_PREFIX:
            Ref: TablePrefix
      Policies:
      - DynamoDBCrudPolicy:
          TableName:
            Fn::Sub: ${TablePrefix}_permanents
  PutRoomPermission:
    Type: AWS::Lambda::Permission
    DependsOn:
    - PutRoomPathsFunction
    Properties:
      Action: lambda:InvokeFunction
      FunctionName:
        Ref: PutRoomPathsFunction
      Principal: appsync.amazonaws.com
  MutationPutRoomBaseFunction:
    Type: AWS::AppSync::FunctionConfiguration
    Properties:
      FunctionVersion: '2018-05-29'
      ApiId:
        Fn::GetAtt:
        - AppSyncAPI
        - ApiId
      Name: PutRoomBase
      Description: Puts a room record into the Permanents table
      DataSourceName:
        Fn::GetAtt:
        - PermanentsDynamoDBTableDataSource
        - Name
      RequestMappingTemplate: "#set( $ddb = $util.dynamodb ) #set( $args = $ctx.prev.result\
        \ ) #set( $PermanentId = $args.PermanentId ) #if($util.isNullOrEmpty($PermanentId))\n\
        \    #set( $PermanentId = $util.autoId() )\n#end #if($args.ParentAncestry)\n\
        \    #set($ancestry = \"${args.ParentAncestry}:${PermanentId}\")\n#else\n\
        \    #set($ancestry = $PermanentId)\n#end {\n    \"version\": \"2017-02-28\"\
        ,\n    \"operation\": \"PutItem\",\n    \"key\": {\n        \"permanentId\"\
        : $ddb.toDynamoDBJson($PermanentId)\n    },\n    \"attributeValues\": {\n\
        \        \"name\": $ddb.toDynamoDBJson($args.Name),\n        \"type\": $ddb.toStringJson(\"\
        ROOM\"),\n        \"ancestry\": $ddb.toStringJson($ancestry)\n        #if($args.Description),\
        \ \"description\": $ddb.toStringJson($args.Description) #end\n        #if($args.ParentId),\
        \ \"parentId\": $ddb.toStringJson($args.ParentId) #end\n    }\n}\n"
      ResponseMappingTemplate: "#set($output = {\n    \"PermanentId\": $ctx.result.permanentId,\n\
        \    \"Type\": \"ROOM\",\n    \"Ancestry\": $ctx.result.ancestry,\n    \"\
        Name\": $ctx.result.name,\n    \"Exits\": $ctx.prev.result.Exits,\n    \"\
        Entries\": $ctx.prev.result.Entries\n}) #if($ctx.prev.result.ParentId)$util.qr($output.put(\"\
        ParentId\", $ctx.prev.result.ParentId))#end #if($ctx.prev.result.Description)$util.qr($output.put(\"\
        Description\", $ctx.prev.result.Description))#end $util.toJson($output)\n"
  PutRoomPathsDataSource:
    Type: AWS::AppSync::DataSource
    Properties:
      ApiId:
        Fn::GetAtt:
        - AppSyncAPI
        - ApiId
      Name: PutRoomPath
      Type: AWS_LAMBDA
      ServiceRoleArn:
        Fn::GetAtt:
        - AppSyncAPIExecutionRole
        - Arn
      LambdaConfig:
        LambdaFunctionArn:
          Fn::GetAtt:
          - PutRoomPathsFunction
          - Arn
  MutationPutRoomPathsFunction:
    Type: AWS::AppSync::FunctionConfiguration
    Properties:
      FunctionVersion: '2018-05-29'
      ApiId:
        Fn::GetAtt:
        - AppSyncAPI
        - ApiId
      Name: PutRoomPaths
      Description: Puts the needed entry records into the Permanents table
      DataSourceName:
        Fn::GetAtt:
        - PutRoomPathsDataSource
        - Name
      RequestMappingTemplate: "{\n    \"version\": \"2017-02-28\",\n    \"operation\"\
        : \"Invoke\",\n    \"payload\": {\n        \"source\": {\n            \"PermanentId\"\
        : $util.toJson($ctx.prev.result.PermanentId),\n            \"Ancestry\": $util.toJson($ctx.prev.result.Ancestry)\n\
        \        },\n        \"Exits\": $util.toJson($ctx.prev.result.Exits),\n  \
        \      \"Entries\": $util.toJson($ctx.prev.result.Entries)\n    }\n}\n"
      ResponseMappingTemplate: "#set($output = {\n    \"PermanentId\": $ctx.prev.result.PermanentId,\n\
        \    \"Type\": \"ROOM\",\n    \"Ancestry\": $ctx.prev.result.Ancestry,\n \
        \   \"Name\": $ctx.prev.result.Name,\n    \"Exits\": $ctx.prev.result.Exits,\n\
        \    \"Entries\": $ctx.prev.result.Entries\n}) #if($ctx.prev.result.ParentId)$util.qr($output.put(\"\
        ParentId\", $ctx.prev.result.ParentId))#end #if($ctx.prev.result.Description)$util.qr($output.put(\"\
        Description\", $ctx.prev.result.Description))#end $util.toJson($output)\n"
  MutationPutRoom:
    Type: AWS::AppSync::Resolver
    Properties:
      ApiId:
        Fn::GetAtt:
        - AppSyncAPI
        - ApiId
      TypeName: Mutation
      FieldName: putRoom
      Kind: PIPELINE
      PipelineConfig:
        Functions:
        - Fn::GetAtt:
          - MutationPutRoomBaseFunction
          - FunctionId
        - Fn::GetAtt:
          - MutationPutRoomPathsFunction
          - FunctionId
      RequestMappingTemplate: $utils.toJson($ctx.args)
      ResponseMappingTemplate: $utils.toJson($ctx.result)
  Schema:
    Type: AWS::AppSync::GraphQLSchema
    Properties:
      ApiId:
        Fn::GetAtt:
        - AppSyncAPI
        - ApiId
      Definition: "type Character {\n    PlayerName: String!\n    Name: String!\n\
        \    CharacterId: ID!\n    Pronouns: String\n    FirstImpression: String\n\
        \    Outfit: String\n    OneCoolThing: String\n} type CharacterInPlay {\n\
        \    CharacterId: ID!\n    Character: Character!\n    RoomId: String!\n  \
        \  ConnectionId: String!\n} interface PermanentTreeNode {\n    PermanentId:\
        \ String!\n    Type: String!\n    Name: String!\n    Ancestry: String!\n \
        \   Description: String\n    ParentId: String\n} type Neighborhood implements\
        \ PermanentTreeNode {\n    PermanentId: String!\n    Type: String!\n    Name:\
        \ String!\n    Ancestry: String!\n    Description: String\n    ParentId: String\n\
        } interface RoomPath {\n    PermanentId: String\n    Name: String!\n    RoomId:\
        \ String\n    Ancestry: String\n} type Exit implements RoomPath {\n    PermanentId:\
        \ String!\n    Name: String!\n    RoomId: String!\n    Ancestry: String!\n\
        } type Entry implements RoomPath {\n    PermanentId: String!\n    Name: String!\n\
        \    RoomId: String!\n    Ancestry: String!\n} input PathInput {\n    PermanentId:\
        \ String\n    Name: String!\n    RoomId: String\n} type Room implements PermanentTreeNode\
        \ {\n    PermanentId: String!\n    Type: String!\n    Name: String!\n    Ancestry:\
        \ String!\n    Description: String\n    ParentId: String\n    Exits: [Exit]\n\
        \    Entries: [Entry]\n} type Mutation {\n    putCharacter(\n        Name:\
        \ String!,\n        CharacterId: String,\n        Pronouns: String,\n    \
        \    FirstImpression: String,\n        Outfit: String,\n        OneCoolThing:\
        \ String\n    ): Character\n    addCharacterInPlay(\n        CharacterId:\
        \ String!\n        ConnectionId: String!\n    ): CharacterInPlay\n    deleteCharacterInPlay(\n\
        \        CharacterId: String!\n    ): CharacterInPlay\n    moveCharacter(\n\
        \        CharacterId: String!\n        RoomId: String!\n    ): CharacterInPlay\n\
        \    putNeighborhood(\n        PermanentId: String\n        Name: String!\n\
        \        Description: String\n        ParentId: String\n    ): Neighborhood\n\
        \    putRoom(\n        PermanentId: String\n        Name: String!\n      \
        \  Description: String\n        ParentId: String\n        Exits: [PathInput]\n\
        \        Entries: [PathInput]\n    ): Room\n} type Query {\n    getCharacter(playerName:\
        \ String!, name: String!): Character\n    getPlayerCharacters: [Character]\n\
        \    getCharactersInPlay: [CharacterInPlay]\n    getNeighborhoodTree: [PermanentTreeNode]\n\
        \    getNeighborhood(PermanentId: String!): Neighborhood\n    getRoom(PermanentId:\
        \ String!): Room\n    getRoomByCharacter(CharacterId: String!): Room\n} type\
        \ Subscription {\n    changedCharacter: Character\n    @aws_subscribe(mutations:\
        \ [\"putCharacter\"])\n    changedCharactersInPlay: CharacterInPlay\n    @aws_subscribe(mutations:\
        \ [\"addCharacterInPlay\", \"deleteCharacterInPlay\", \"moveCharacter\"])\n\
        \    changedNeighborhood: Neighborhood\n    @aws_subscribe(mutations: [\"\
        putNeighborhood\"])\n    changedRoom: Room\n    @aws_subscribe(mutations:\
        \ [\"putRoom\"])\n} schema {\n    mutation: Mutation\n    query: Query\n \
        \   subscription: Subscription\n}\n"
