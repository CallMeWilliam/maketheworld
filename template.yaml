AWSTemplateFormatVersion: '2010-09-09'
Transform: AWS::Serverless-2016-10-31
Description: >
  burnedover-mush-app

  SAM Template for burnedover-mush, a serverless multiplayer text roleplaying system,
  with DynamoDB storage, React front-end and administrative tools.

Parameters:
  TablePrefix:
    Type: String
    Default: 'burnedover'
    Description: (Required) The name of the new DynamoDB to store connection identifiers for each connected clients. Minimum 3 characters
    MinLength: 3
    MaxLength: 50
    AllowedPattern: ^[A-Za-z_]+$
    ConstraintDescription: 'Required. Can be characters and underscore only. No numbers or special characters allowed.'
  PermanentsStack:
    Type: String
    Default: 'BurnedOverPermanentsStack'
    Description: (Required) The name of the stack containing the permanents DynamoDB table.
    MinLength: 3
    MaxLength: 50
    AllowedPattern: ^[A-Za-z_]+$
    ConstraintDescription: 'Required. Can be characters and underscore only. No numbers or special characters allowed.'

Resources:
  RealTimeWebSocket:
    Type: AWS::ApiGatewayV2::Api
    Properties:
      Name: BurnedOverRealTimeSocket
      ProtocolType: WEBSOCKET
      RouteSelectionExpression: "$request.body.message"
  ConnectRoute:
    Type: AWS::ApiGatewayV2::Route
    Properties:
      ApiId: !Ref RealTimeWebSocket
      RouteKey: $connect
      AuthorizationType: NONE
      OperationName: ConnectRoute
      Target: !Join
        - '/'
        - - 'integrations'
          - !Ref ConnectInteg
  ConnectInteg:
    Type: AWS::ApiGatewayV2::Integration
    Properties:
      ApiId: !Ref RealTimeWebSocket
      Description: Connect Integration
      IntegrationType: AWS_PROXY
      IntegrationUri: 
        Fn::Sub:
            arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${OnConnectFunction.Arn}/invocations
  DisconnectRoute:
    Type: AWS::ApiGatewayV2::Route
    Properties:
      ApiId: !Ref RealTimeWebSocket
      RouteKey: $disconnect
      AuthorizationType: NONE
      OperationName: DisconnectRoute
      Target: !Join
        - '/'
        - - 'integrations'
          - !Ref DisconnectInteg
  DisconnectInteg:
    Type: AWS::ApiGatewayV2::Integration
    Properties:
      ApiId: !Ref RealTimeWebSocket
      Description: Disconnect Integration
      IntegrationType: AWS_PROXY
      IntegrationUri: 
        Fn::Sub:
            arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${OnDisconnectFunction.Arn}/invocations
  PingRoute:
    Type: AWS::ApiGatewayV2::Route
    Properties:
      ApiId: !Ref RealTimeWebSocket
      RouteKey: ping
      AuthorizationType: NONE
      OperationName: PingRoute
      RouteResponseSelectionExpression: "$default"
      Target: !Join
        - '/'
        - - 'integrations'
          - !Ref PingInteg
  PingInteg:
    Type: AWS::ApiGatewayV2::Integration
    Properties:
      ApiId: !Ref RealTimeWebSocket
      Description: Ping Integration
      IntegrationType: MOCK
      PassthroughBehavior: WHEN_NO_MATCH
      TemplateSelectionExpression: "application/json"
      RequestTemplates:
        application/json: "{\"statusCode\": 200 }"
  PingIntegrationResponse:
    Type: AWS::ApiGatewayV2::IntegrationResponse
    Properties:
      ApiId: !Ref RealTimeWebSocket
      IntegrationId: !Ref PingInteg
      TemplateSelectionExpression: "$integration.response.statuscode"
      IntegrationResponseKey: "/200/"
      ResponseTemplates:
        "200": "{\"statusCode\": 200, \"type\": \"pong\" }"
  PingResponse:
    Type: AWS::ApiGatewayV2::RouteResponse
    Properties:
      ApiId: !Ref RealTimeWebSocket
      RouteId: !Ref PingRoute
      RouteResponseKey: "$default"
  RegisterCharacterRoute:
    Type: AWS::ApiGatewayV2::Route
    Properties:
      ApiId: !Ref RealTimeWebSocket
      RouteKey: registercharacter
      AuthorizationType: NONE
      OperationName: RegisterCharacterRoute
      Target: !Join
        - '/'
        - - 'integrations'
          - !Ref RegisterCharacterInteg
  RegisterCharacterInteg:
    Type: AWS::ApiGatewayV2::Integration
    Properties:
      ApiId: !Ref RealTimeWebSocket
      Description: Register Name Integtration
      IntegrationType: AWS_PROXY
      IntegrationUri:
        Fn::Sub:
            arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${RegisterCharacterFunction.Arn}/invocations
  RealTimeDeployment:
    Type: AWS::ApiGatewayV2::Deployment
    DependsOn:
    - ConnectRoute
    - PingRoute
    - RegisterCharacterRoute
    - DisconnectRoute
    Properties:
      ApiId: !Ref RealTimeWebSocket
  RealTimeStage:
    Type: AWS::ApiGatewayV2::Stage
    DependsOn:
      - RealTimeDeployment
    Properties:
      StageName: Prod
      Description: Prod Stage
      DeploymentId: !Ref RealTimeDeployment
      ApiId: !Ref RealTimeWebSocket
  CharactersInPlayTable:
    Type: AWS::DynamoDB::Table
    Properties:
      AttributeDefinitions:
      - AttributeName: "CharacterId"
        AttributeType: "S"
      - AttributeName: "RoomId"
        AttributeType: "S"
      - AttributeName: "ConnectionId"
        AttributeType: "S"
      BillingMode: "PAY_PER_REQUEST"
      KeySchema:
      - AttributeName: "CharacterId"
        KeyType: "HASH"
      GlobalSecondaryIndexes:
        - IndexName: RoomIndex
          KeySchema:
            - AttributeName: RoomId
              KeyType: HASH
            - AttributeName: CharacterId
              KeyType: RANGE
          Projection:
            ProjectionType: ALL
        - IndexName: ConnectionIndex
          KeySchema:
            - AttributeName: ConnectionId
              KeyType: HASH
            - AttributeName: CharacterId
              KeyType: RANGE
          Projection:
            ProjectionType: ALL
      SSESpecification:
        SSEEnabled: False
      TimeToLiveSpecification:
        AttributeName: "ExpirationTime"
        Enabled: True
      TableName: !Sub '${TablePrefix}_characters_in_play'
  MessagesTable:
    Type: AWS::DynamoDB::Table
    Properties:
      AttributeDefinitions:
      - AttributeName: "Target"
        AttributeType: "S"
      - AttributeName: "DataCategory"
        AttributeType: "S"
      BillingMode: "PAY_PER_REQUEST"
      KeySchema:
      - AttributeName: "Target"
        KeyType: "HASH"
      - AttributeName: "DataCategory"
        KeyType: "RANGE"
      SSESpecification:
        SSEEnabled: False
      TableName: !Sub '${TablePrefix}_messages'
      TimeToLiveSpecification:
        AttributeName: ExpirationTime
        Enabled: True
  SharedLambdaLayer:
    Type: AWS::Serverless::LayerVersion
    Properties:
        LayerName: shared-layer
        Description: Lambda layer with shared code for functions
        ContentUri: lambda/shared/
        CompatibleRuntimes:
          - nodejs12.x
  UUIDLambdaLayer:
    Type: AWS::Serverless::LayerVersion
    Properties:
        LayerName: uuid-layer
        Description: Lambda layer to import the uuid library
        ContentUri: lambda/uuidLayer/
        CompatibleRuntimes:
          - nodejs12.x
  OnConnectFunction:
    Type: AWS::Serverless::Function
    Properties:
      CodeUri: lambda/onconnect/
      Handler: app.handler
      MemorySize: 256
      Runtime: nodejs12.x
      Environment:
        Variables:
          TABLE_PREFIX: !Ref TablePrefix
  OnConnectPermission:
    Type: AWS::Lambda::Permission
    DependsOn:
      - RealTimeWebSocket
      - OnConnectFunction
    Properties:
      Action: lambda:InvokeFunction
      FunctionName: !Ref OnConnectFunction
      Principal: apigateway.amazonaws.com
  OnDisconnectFunction:
    Type: AWS::Serverless::Function
    Properties:
      CodeUri: lambda/ondisconnect/
      Handler: app.handler
      MemorySize: 256
      Runtime: nodejs12.x
      Environment:
        Variables:
          TABLE_PREFIX: !Ref TablePrefix
          APPSYNC_ENDPOINT_URL: !GetAtt AppSyncAPI.GraphQLUrl
      Policies:
      - Statement:
        - Effect: Allow
          Action:
          - 'execute-api:ManageConnections'
          Resource:
          - !Sub 'arn:aws:execute-api:${AWS::Region}:${AWS::AccountId}:${RealTimeWebSocket}/*'
      - Statement:
        - Effect: Allow
          Action: appsync:GraphQL
          Resource: !Sub '${AppSyncAPI}/*'
  OnDisconnectPermission:
    Type: AWS::Lambda::Permission
    DependsOn:
      - RealTimeWebSocket
      - OnDisconnectFunction
    Properties:
      Action: lambda:InvokeFunction
      FunctionName: !Ref OnDisconnectFunction
      Principal: apigateway.amazonaws.com
  RegisterCharacterFunction:
    Type: AWS::Serverless::Function
    Properties:
      CodeUri: lambda/registercharacter/
      Handler: app.handler
      MemorySize: 256
      Runtime: nodejs12.x
      Layers:
        - !Ref SharedLambdaLayer
      Environment:
        Variables:
          TABLE_PREFIX: !Ref TablePrefix
          APPSYNC_ENDPOINT_URL: !GetAtt AppSyncAPI.GraphQLUrl
      Policies:
      - Statement:
        - Effect: Allow
          Action:
          - 'execute-api:ManageConnections'
          Resource:
          - !Sub 'arn:aws:execute-api:${AWS::Region}:${AWS::AccountId}:${RealTimeWebSocket}/*'
      - Statement:
        - Effect: Allow
          Action: appsync:GraphQL
          Resource: !Sub '${AppSyncAPI}/*'
  RegisterCharacterPermission:
    Type: AWS::Lambda::Permission
    DependsOn:
      - RealTimeWebSocket
      - RegisterCharacterFunction
    Properties:
      Action: lambda:InvokeFunction
      FunctionName: !Ref RegisterCharacterFunction
      Principal: apigateway.amazonaws.com
  AppSyncAPI:
      Type: AWS::AppSync::GraphQLApi
      Properties:
          Name: !Sub ${TablePrefix}AppSyncAPI
          AuthenticationType: AMAZON_COGNITO_USER_POOLS
          UserPoolConfig:
              AwsRegion: us-east-1
              UserPoolId:
                Fn::ImportValue:
                  !Sub "${PermanentsStack}-UserPoolId"
              DefaultAction: ALLOW
          AdditionalAuthenticationProviders:
              - AuthenticationType: AWS_IAM
  AppSyncAPIExecutionRole:
      Type: AWS::IAM::Role
      Properties:
          AssumeRolePolicyDocument:
              Statement:
                - Effect: Allow
                  Principal:
                      Service: appsync.amazonaws.com
                  Action:
                      - sts:AssumeRole
          Policies:
            - PolicyName: CharactersPolicy
              PolicyDocument:
                  Version: "2012-10-17"
                  Statement:
                    - Effect: "Allow"
                      Action:
                          - "dynamodb:GetItem"
                          - "dynamodb:BatchGetItem"
                          - "dynamodb:Query"
                          - "dynamodb:PutItem"
                      Resource: !Sub "arn:aws:dynamodb:*:*:table/${TablePrefix}_characters"
            - PolicyName: CharacterIndexPolicy
              PolicyDocument:
                  Version: "2012-10-17"
                  Statement:
                    - Effect: "Allow"
                      Action:
                          - "dynamodb:Query"
                      Resource: !Sub "arn:aws:dynamodb:*:*:table/${TablePrefix}_characters/*"
            - PolicyName: PlayersPolicy
              PolicyDocument:
                  Version: "2012-10-17"
                  Statement:
                    - Effect: "Allow"
                      Action:
                          - "dynamodb:GetItem"
                          - "dynamodb:BatchGetItem"
                          - "dynamodb:Query"
                          - "dynamodb:PutItem"
                      Resource: !Sub "arn:aws:dynamodb:*:*:table/${TablePrefix}_players"
            - PolicyName: PlayerIndexPolicy
              PolicyDocument:
                  Version: "2012-10-17"
                  Statement:
                    - Effect: "Allow"
                      Action:
                          - "dynamodb:Query"
                      Resource: !Sub "arn:aws:dynamodb:*:*:table/${TablePrefix}_players/*"
            - PolicyName: CharactersInPlayPolicy
              PolicyDocument:
                  Version: "2012-10-17"
                  Statement:
                    - Effect: "Allow"
                      Action:
                          - "dynamodb:GetItem"
                          - "dynamodb:BatchGetItem"
                          - "dynamodb:Query"
                          - "dynamodb:PutItem"
                          - "dynamodb:UpdateItem"
                          - "dynamodb:Scan"
                      Resource: !Sub "arn:aws:dynamodb:*:*:table/${TablePrefix}_characters_in_play"
            - PolicyName: ConnectonsIndexPolicy
              PolicyDocument:
                  Version: "2012-10-17"
                  Statement:
                    - Effect: "Allow"
                      Action:
                          - "dynamodb:Query"
                      Resource: !Sub "arn:aws:dynamodb:*:*:table/${TablePrefix}_characters_in_play/*"
            - PolicyName: PermanentsPolicy
              PolicyDocument:
                  Version: "2012-10-17"
                  Statement:
                    - Effect: "Allow"
                      Action:
                          - "dynamodb:GetItem"
                          - "dynamodb:BatchGetItem"
                          - "dynamodb:Query"
                          - "dynamodb:PutItem"
                          - "dynamodb:UpdateItem"
                          - "dynamodb:Scan"
                      Resource: !Sub "arn:aws:dynamodb:*:*:table/${TablePrefix}_permanents"
            - PolicyName: PermanentsIndexPolicy
              PolicyDocument:
                  Version: "2012-10-17"
                  Statement:
                    - Effect: "Allow"
                      Action:
                          - "dynamodb:Query"
                      Resource: !Sub "arn:aws:dynamodb:*:*:table/${TablePrefix}_permanents/*"
            - PolicyName: MessagesPolicy
              PolicyDocument:
                  Version: "2012-10-17"
                  Statement:
                    - Effect: "Allow"
                      Action:
                          - "dynamodb:GetItem"
                          - "dynamodb:BatchGetItem"
                          - "dynamodb:Query"
                          - "dynamodb:PutItem"
                          - "dynamodb:UpdateItem"
                          - "dynamodb:Scan"
                      Resource: !Sub "arn:aws:dynamodb:*:*:table/${TablePrefix}_messages"
            - PolicyName: MessagesIndexPolicy
              PolicyDocument:
                  Version: "2012-10-17"
                  Statement:
                    - Effect: "Allow"
                      Action:
                          - "dynamodb:Query"
                      Resource: !Sub "arn:aws:dynamodb:*:*:table/${TablePrefix}_messages/*"
            - PolicyName: PutRoomPathsPolicy
              PolicyDocument:
                  Version: "2012-10-17"
                  Statement:
                    - Effect: "Allow"
                      Action:
                          - "lambda:InvokeFunction"
                      Resource: !GetAtt PutRoomPathsFunction.Arn
  PlayerDynamoDBTableDataSource:
    Type: AWS::AppSync::DataSource
    Properties:
        ApiId: !GetAtt AppSyncAPI.ApiId
        Name: Player
        Type: AMAZON_DYNAMODB
        ServiceRoleArn: !GetAtt "AppSyncAPIExecutionRole.Arn"
        DynamoDBConfig:
            AwsRegion: us-east-1
            TableName: !Sub ${TablePrefix}_players
  CharactersInPlayDynamoDBTableDataSource:
      Type: AWS::AppSync::DataSource
      Properties:
          ApiId: !GetAtt AppSyncAPI.ApiId
          Name: CharactersInPlay
          Type: AMAZON_DYNAMODB
          ServiceRoleArn: !GetAtt "AppSyncAPIExecutionRole.Arn"
          DynamoDBConfig:
              AwsRegion: us-east-1
              TableName: !Sub ${TablePrefix}_characters_in_play
  PermanentsDynamoDBTableDataSource:
      Type: AWS::AppSync::DataSource
      Properties:
          ApiId: !GetAtt AppSyncAPI.ApiId
          Name: Permanents
          Type: AMAZON_DYNAMODB
          ServiceRoleArn: !GetAtt "AppSyncAPIExecutionRole.Arn"
          DynamoDBConfig:
              AwsRegion: us-east-1
              TableName: !Sub ${TablePrefix}_permanents
  MessagesDynamoDBTableDataSource:
    Type: AWS::AppSync::DataSource
    Properties:
        ApiId: !GetAtt AppSyncAPI.ApiId
        Name: Messages
        Type: AMAZON_DYNAMODB
        ServiceRoleArn: !GetAtt "AppSyncAPIExecutionRole.Arn"
        DynamoDBConfig:
            AwsRegion: us-east-1
            TableName: !Sub ${TablePrefix}_messages
  QueryGetPlayerResolver:
    Type: AWS::AppSync::Resolver
    DependsOn: Schema
    Properties:
        ApiId: !GetAtt AppSyncAPI.ApiId
        TypeName: Query
        FieldName: getPlayer
        DataSourceName: !GetAtt PlayerDynamoDBTableDataSource.Name
        RequestMappingTemplate: >
            {
                "version": "2017-02-28",
                "operation": "GetItem",
                "key": {
                    "PlayerName": $util.dynamodb.toStringJson($ctx.args.PlayerName),
                    "DataCategory": $util.dynamodb.toStringJson("Details")
                }
            }
        ResponseMappingTemplate: >
            #set($Consent = false)
            #if ($ctx.result && $util.isBoolean($ctx.result.CodeOfConductConsent))
                #set($Consent = $ctx.result.CodeOfConductConsent)
            #end
            $util.toJson({
                "PlayerName": $ctx.args.PlayerName,
                "CodeOfConductConsent": $Consent
            })
  MutationPutPlayerResolver:
    Type: AWS::AppSync::Resolver
    DependsOn: Schema
    Properties:
        ApiId: !GetAtt AppSyncAPI.ApiId
        TypeName: Mutation
        FieldName: putPlayer
        DataSourceName: !GetAtt PlayerDynamoDBTableDataSource.Name
        RequestMappingTemplate: >
            #set($PlayerName = $ctx.args.PlayerName)
            #if ($util.isNullOrEmpty($PlayerName))
              #set($PlayerName = $context.identity.username)
            #end
            {
                "version": "2017-02-28",
                "operation": "PutItem",
                "key": {
                    "PlayerName": $util.dynamodb.toStringJson($PlayerName),
                    "DataCategory": $util.dynamodb.toStringJson("Details")
                },
                "attributeValues": {
                    "CodeOfConductConsent":
                      #if($ctx.args.CodeOfConductConsent)
                        $util.dynamodb.toBooleanJson($ctx.args.CodeOfConductConsent)
                      #else
                        $util.dynamodb.toBooleanJson(false)
                      #end
                }
            }
        ResponseMappingTemplate: $util.toJson($ctx.result)
  QueryGetCharacterResolver:
      Type: AWS::AppSync::Resolver
      DependsOn: Schema
      Properties:
          ApiId: !GetAtt AppSyncAPI.ApiId
          TypeName: Query
          FieldName: getCharacter
          DataSourceName: !GetAtt PlayerDynamoDBTableDataSource.Name
          RequestMappingTemplate: >
              {
                  "version": "2017-02-28",
                  "operation": "Query",
                  "query": {
                    "expression": "DataCategory = :CharacterLookup",
                    "expressionValues": {
                      ":CharacterLookup": $util.dynamodb.toStringJson("Character#$ctx.args.characterId")
                    }
                  },
                  "index": "CategoryIndex",
                  "limit": 1
              }
          ResponseMappingTemplate: >
              #if($ctx.result.items)
                #set($result = $ctx.result.items[0])
                #if($util.isNull($result.Pronouns)) $util.qr($result.put("Pronouns", "")) #end
                #if($util.isNull($result.FirstImpression)) $util.qr($result.put("FirstImpression", "")) #end
                #if($util.isNull($result.Outfit)) $util.qr($result.put("Outfit", "")) #end
                #if($util.isNull($result.OneCoolThing)) $util.qr($result.put("OneCoolThing", "")) #end
                #if($util.isNull($result.HomeId)) $util.qr($result.put("HomeId", "")) #end
                $util.toJson($result)
              #else
                $util.toJson({})
              #end
  QueryPlayerCharactersResolver:
      Type: AWS::AppSync::Resolver
      DependsOn: Schema
      Properties:
          ApiId: !GetAtt AppSyncAPI.ApiId
          TypeName: Query
          FieldName: getPlayerCharacters
          DataSourceName: !GetAtt PlayerDynamoDBTableDataSource.Name
          RequestMappingTemplate: >
              {
                  "version": "2017-02-28",
                  "operation": "Query",
                  "query": {
                      "expression": "PlayerName = :PlayerName and begins_with(DataCategory, :CharacterPrefix)",
                      "expressionValues": {
                          ":PlayerName": $util.dynamodb.toDynamoDBJson($context.identity.username),
                          ":CharacterPrefix": $util.dynamodb.toStringJson("Character#")
                      }
                  }
              }
          ResponseMappingTemplate: >
            #set($result = [])
            #foreach($item in $ctx.result.items)
              #if($util.isNull($item.Pronouns)) $util.qr($item.put("Pronouns", "")) #end
              #if($util.isNull($item.FirstImpression)) $util.qr($item.put("FirstImpression", "")) #end
              #if($util.isNull($item.Outfit)) $util.qr($item.put("Outfit", "")) #end
              #if($util.isNull($item.OneCoolThing)) $util.qr($item.put("OneCoolThing", "")) #end
              #if($util.isNull($item.HomeId)) $util.qr($item.put("HomeId", "")) #end
              $util.qr($result.add($item))
            #end
            $util.toJson($result)
  PutCharacterResolver:
      Type: AWS::AppSync::Resolver
      DependsOn: Schema
      Properties:
          ApiId: !GetAtt AppSyncAPI.ApiId
          TypeName: Mutation
          FieldName: putCharacter
          DataSourceName: !GetAtt PlayerDynamoDBTableDataSource.Name
          RequestMappingTemplate: >
              #if(!($ctx.args.CharacterId))
                  $util.qr($ctx.args.put("CharacterId", $util.autoId()))
              #end
              #set( $ddb = $util.dynamodb )
              {
                  "version": "2017-02-28",
                  "operation": "PutItem",
                  "key": {
                      "PlayerName": $ddb.toStringJson($context.identity.username),
                      "DataCategory": $ddb.toStringJson("Character#$ctx.args.CharacterId")
                  },
                  "attributeValues": {
                      "CharacterId": $ddb.toStringJson($ctx.args.CharacterId),
                      "Name": $ddb.toStringJson($ctx.args.Name)
                      #if($ctx.args.Pronouns), "Pronouns": $ddb.toStringJson($ctx.args.Pronouns) #end
                      #if($ctx.args.FirstImpression), "FirstImpression": $ddb.toStringJson($ctx.args.FirstImpression) #end
                      #if($ctx.args.OneCoolThing), "OneCoolThing": $ddb.toStringJson($ctx.args.OneCoolThing) #end
                      #if($ctx.args.Outfit), "Outfit": $ddb.toStringJson($ctx.args.Outfit) #end
                      #if($ctx.args.HomeId), "HomeId": $ddb.toStringJson($ctx.args.HomeId) #end
                  }
              }
          ResponseMappingTemplate: >
            #if($ctx.result)
              #set($result = $ctx.result)
              #if($util.isNull($result.Pronouns)) $util.qr($result.put("Pronouns", "")) #end
              #if($util.isNull($result.FirstImpression)) $util.qr($result.put("FirstImpression", "")) #end
              #if($util.isNull($result.Outfit)) $util.qr($result.put("Outfit", "")) #end
              #if($util.isNull($result.OneCoolThing)) $util.qr($result.put("OneCoolThing", "")) #end
              #if($util.isNull($result.HomeId)) $util.qr($result.put("HomeId", "")) #end
              $util.toJson($result)
            #else
              $util.toJson({})
            #end
  CharacterInPlayGetCharacter:
      Type: AWS::AppSync::Resolver
      DependsOn: Schema
      Properties:
          ApiId: !GetAtt AppSyncAPI.ApiId
          TypeName: CharacterInPlay
          FieldName: Character
          DataSourceName: !GetAtt PlayerDynamoDBTableDataSource.Name
          RequestMappingTemplate: >
              {
                  "version": "2017-02-28",
                  "operation": "GetItem",
                  "key": {
                      "PlayerName": $util.dynamodb.toStringJson($context.source.PlayerName),
                      "DataCategory": $util.dynamodb.toStringJson("Character#$context.source.CharacterId")
                  }
              }
          ResponseMappingTemplate: >
              #if($ctx.result.items)
                #set($result = $ctx.result.items[0])
                $util.toJson({
                  "PlayerName": "$result.PlayerName",
                  "Name": "$result.Name",
                  "CharacterId": "$ctx.args.characterId",
                  "Pronouns": "$result.Pronouns",
                  "FirstImpression": "$result.FirstImpression",
                  "Outfit": "$result.Outfit",
                  "OneCoolThing": "$result.OneCoolThing",
                  "HomeId": "$result.HomeId"
                })
              #else
                $util.toJson({})
              #end
          ResponseMappingTemplate: "$util.toJson($ctx.result)"
  QueryGetCharactersInPlay:
      Type: AWS::AppSync::Resolver
      DependsOn: Schema
      Properties:
          ApiId: !GetAtt AppSyncAPI.ApiId
          TypeName: Query
          FieldName: getCharactersInPlay
          DataSourceName: !GetAtt CharactersInPlayDynamoDBTableDataSource.Name
          RequestMappingTemplate: >
              {
                  "version": "2017-02-28",
                  "operation": "Scan"
              }
          ResponseMappingTemplate: "$util.toJson($ctx.result.items)"
  QueryGetNeighborhoodTree:
      Type: AWS::AppSync::Resolver
      DependsOn: Schema
      Properties:
          ApiId: !GetAtt AppSyncAPI.ApiId
          TypeName: Query
          FieldName: getNeighborhoodTree
          DataSourceName: !GetAtt PermanentsDynamoDBTableDataSource.Name
          RequestMappingTemplate: >
              {
                  "version": "2018-05-29",
                  "operation": "Scan",
                  "filter": {
                      "expression": "#t = :neighborhood or #t = :room",
                      "expressionNames": {
                          "#t": "type"
                      },
                      "expressionValues": {
                          ":neighborhood": $util.dynamodb.toStringJson("NEIGHBORHOOD"),
                          ":room": $util.dynamodb.toStringJson("ROOM")
                      }
                  }
              }
          ResponseMappingTemplate: >
              #set($output = [])
              #foreach($node in $ctx.result.items)
                  #if($node.type == "NEIGHBORHOOD")
                      #set($typeName = "Neighborhood")
                  #else
                      #set($typeName = "Room")
                  #end
                  $util.qr($output.add({
                      "__typename": $typeName,
                      "Name": $node.name,
                      "Type": $node.type,
                      "PermanentId": $node.permanentId,
                      "ParentId": $node.parentId,
                      "Ancestry": $node.ancestry,
                      "Description": $node.description
                  }))
              #end
              $util.toJson($output)
  QueryGetNeighborhood:
      Type: AWS::AppSync::Resolver
      DependsOn: Schema
      Properties:
          ApiId: !GetAtt AppSyncAPI.ApiId
          TypeName: Query
          FieldName: getNeighborhood
          DataSourceName: !GetAtt PermanentsDynamoDBTableDataSource.Name
          RequestMappingTemplate: >
              {
                  "version": "2017-02-28",
                  "operation": "GetItem",
                  "key": {
                      "permanentId": $util.dynamodb.toDynamoDBJson($ctx.args.PermanentId)
                  }
              }
          ResponseMappingTemplate: >
              #if($ctx.result.type == "NEIGHBORHOOD")
                  {
                      "PermanentId": $util.toJson($ctx.result.permanentId),
                      "ParentId": $util.toJson($ctx.result.parentId),
                      "PermanentId": $util.toJson($ctx.result.permanentId),
                      "Name": $util.toJson($ctx.result.name),
                      "Type": $util.toJson($ctx.result.type),
                      "Ancestry": $util.toJson($ctx.result.ancestry),
                      "Description": $util.toJson($ctx.result.description)
                  }
              #else
                  $util.error("PermanentId must specify a NEIGHBORHOOD type permanent")
              #end
  QueryGetRoom:
      Type: AWS::AppSync::Resolver
      DependsOn: Schema
      Properties:
          ApiId: !GetAtt AppSyncAPI.ApiId
          TypeName: Query
          FieldName: getRoom
          DataSourceName: !GetAtt PermanentsDynamoDBTableDataSource.Name
          RequestMappingTemplate: >
              {
                  "version": "2017-02-28",
                  "operation": "GetItem",
                  "key": {
                      "permanentId": $util.dynamodb.toDynamoDBJson($ctx.args.PermanentId)
                  }
              }
          ResponseMappingTemplate: >
              #if($ctx.result.type == "ROOM")
                  {
                      "PermanentId": $util.toJson($ctx.result.permanentId),
                      "ParentId": $util.toJson($ctx.result.parentId),
                      "PermanentId": $util.toJson($ctx.result.permanentId),
                      "Name": $util.toJson($ctx.result.name),
                      "Type": $util.toJson($ctx.result.type),
                      "Ancestry": $util.toJson($ctx.result.ancestry),
                      "Description": $util.toJson($ctx.result.description)
                  }
              #else
                  $util.error("PermanentId must specify a ROOM type permanent")
              #end
  QueryGetRoomExitsFunction:
      Type: AWS::AppSync::FunctionConfiguration
      Properties:
          FunctionVersion: "2018-05-29"
          ApiId: !GetAtt AppSyncAPI.ApiId
          Name: GetRoomExitsFunction
          DataSourceName: !GetAtt PermanentsDynamoDBTableDataSource.Name
          RequestMappingTemplate: >
              {
                  "version": "2017-02-28",
                  "operation": "Query",
                  "query": {
                      "expression": "fromRoomId = :RoomId",
                      "expressionValues": {
                          ":RoomId": $util.dynamodb.toDynamoDBJson($ctx.prev.result.PermanentId)
                      }
                  },
                  "index": "fromRoomIndex"
              }
          ResponseMappingTemplate: >
              [
                  #foreach($exit in $ctx.result.items)
                      {
                          "PermanentId": $util.toJson($exit.permanentId),
                          "Name": $util.toJson($exit.name),
                          "RoomId": $util.toJson($exit.parentId),
                          "Ancestry": $util.toJson($exit.ancestry)
                      }#if($foreach.hasNext),#end
                  #end
              ]
  QueryRoomGetRoomExits:
      Type: AWS::AppSync::Resolver
      DependsOn: Schema
      Properties:
        ApiId: !GetAtt AppSyncAPI.ApiId
        TypeName: Room
        FieldName: Exits
        Kind: PIPELINE
        PipelineConfig:
            Functions:
                - !GetAtt QueryGetRoomExitsFunction.FunctionId
        RequestMappingTemplate: >
            {
                "PermanentId": $util.toJson($ctx.source.PermanentId)
            }
        ResponseMappingTemplate: "$util.toJson($ctx.result)"
  QueryGetRoomEntriesFunction:
      Type: AWS::AppSync::FunctionConfiguration
      Properties:
          FunctionVersion: "2018-05-29"
          ApiId: !GetAtt AppSyncAPI.ApiId
          Name: GetRoomEntriesFunction
          DataSourceName: !GetAtt PermanentsDynamoDBTableDataSource.Name
          RequestMappingTemplate: >
              {
                  "version": "2017-02-28",
                  "operation": "Query",
                  "query": {
                      "expression": "parentId = :RoomId",
                      "expressionValues": {
                          ":RoomId": $util.dynamodb.toDynamoDBJson($ctx.prev.result.PermanentId)
                      }
                  },
                  "index": "parentIndex"
              }
          ResponseMappingTemplate: >
              [
                  #foreach($entry in $ctx.result.items)
                      {
                          "PermanentId": $util.toJson($entry.permanentId),
                          "Name": $util.toJson($entry.name),
                          "RoomId": $util.toJson($entry.fromRoomId),
                          "Ancestry": $util.toJson($entry.ancestry)
                      }#if($foreach.hasNext),#end
                  #end
              ]
  QueryRoomGetRoomEntries:
      Type: AWS::AppSync::Resolver
      DependsOn: Schema
      Properties:
          ApiId: !GetAtt AppSyncAPI.ApiId
          TypeName: Room
          FieldName: Entries
          Kind: PIPELINE
          PipelineConfig:
              Functions:
                  - !GetAtt QueryGetRoomEntriesFunction.FunctionId
          RequestMappingTemplate: >
              {
                  "PermanentId": $util.toJson($ctx.source.PermanentId)
              }
          ResponseMappingTemplate: "$util.toJson($ctx.result)"
  QueryGetRoomRecap:
    Type: AWS::AppSync::Resolver
    DependsOn: Schema
    Properties:
        ApiId: !GetAtt AppSyncAPI.ApiId
        TypeName: Query
        FieldName: getRoomRecap
        DataSourceName: !GetAtt MessagesDynamoDBTableDataSource.Name
        RequestMappingTemplate: >
            {
                "version": "2017-02-28",
                "operation": "Query",
                "query": {
                  "expression": "Target = :RoomId",
                  "expressionValues": {
                      ":RoomId": $util.dynamodb.toDynamoDBJson("ROOM#$ctx.args.PermanentId")
                  }
                },
                "scanIndexForward": false,
                "limit": 10
            }
        ResponseMappingTemplate: >
            #set($output = [])
            #foreach($message in $ctx.result.items)
                #set($split = $message.DataCategory.split("#"))
                $util.qr($output.add({
                    "RoomId": "$ctx.args.PermanentId",
                    "Type": "$util.defaultIfNull($message.Type, 'ROOM')",
                    "CreatedTime": $split[0],
                    "MessageId": "$split[1]",
                    "Recap": true,
                    "Message": "$message.Message",
                    "FromCharacterId": "$util.defaultIfNull($message.FromCharacterId, '')",
                    "Title": "$util.defaultIfNull($message.Title, '')"
                }))
            #end
            $util.toJson($output)
  MutationPreQueryCharacterInPlay:
      Type: AWS::AppSync::FunctionConfiguration
      Properties:
          FunctionVersion: "2018-05-29"
          ApiId: !GetAtt AppSyncAPI.ApiId
          Name: PreQueryCharacterInPlay
          Description: Checks before adding a character to see if a past record exists to reactivate
          DataSourceName: !GetAtt CharactersInPlayDynamoDBTableDataSource.Name
          RequestMappingTemplate: >
              #if (!$ctx.prev.result.CharacterId)
                  $ctx.error("CharacterId required")
              #end
              {
                  "version": "2017-02-28",
                  "operation": "GetItem",
                  "key": {
                      "CharacterId": $util.dynamodb.toDynamoDBJson($ctx.prev.result.CharacterId)
                  }
              }
          ResponseMappingTemplate: >
              #if ($ctx.result.PlayerName)
                  {
                      "CharacterId": "$ctx.prev.result.CharacterId",
                      "ConnectionId": "$ctx.prev.result.ConnectionId",
                      "PlayerName": "$ctx.result.PlayerName",
                      "Name": "$ctx.result.Name",
                      "RoomId": "$ctx.result.RoomId",
                      "Reactivate": true
                  }
              #else
                  {
                      "CharacterId": "$ctx.prev.result.CharacterId",
                      "ConnectionId": "$ctx.prev.result.ConnectionId",
                      "Reactivate": false
                  }
              #end
  MutationPreQueryCharacterIfNeeded:
      Type: AWS::AppSync::FunctionConfiguration
      Properties:
          FunctionVersion: "2018-05-29"
          ApiId: !GetAtt AppSyncAPI.ApiId
          Name: PreQueryCharacterIfNeeded
          Description: Checks if needed before adding a character to find PlayerName and Name
          DataSourceName: !GetAtt PlayerDynamoDBTableDataSource.Name
          RequestMappingTemplate: >
              #if ($ctx.prev.result.Reactivate)
                  #return($ctx.prev.result)
              #end
              {
                  "version": "2017-02-28",
                  "operation": "Query",
                  "query": {
                    "expression": "DataCategory = :CharacterLookup",
                    "expressionValues": {
                      ":CharacterLookup": $util.dynamodb.toStringJson("Character#$ctx.prev.result.CharacterId")
                    }
                  },
                  "index": "CategoryIndex",
                  "limit": 1
              }
          ResponseMappingTemplate: >
              #if ($ctx.error)
                  $util.error($ctx.error.message, $ctx.error.type)
              #end
              #if($ctx.result.scannedCount)
                #set($result = $ctx.result.items[0])
                $util.toJson({
                  "CharacterId": "$ctx.prev.result.CharacterId",
                  "ConnectionId": "$ctx.prev.result.ConnectionId",
                  "PlayerName": "$result.PlayerName",
                  "Name": "$result.Name",
                  "RoomId": "VORTEX",
                  "Reactivate": false
                })
              #else
                $util.error("No character found")
              #end
  MutationAddCharacterInPlayPutFunction:
      Type: AWS::AppSync::FunctionConfiguration
      Properties:
          FunctionVersion: "2018-05-29"
          ApiId: !GetAtt AppSyncAPI.ApiId
          Name: AddCharacterInPlay
          Description: Adds or activates a CharacterInPlay record
          DataSourceName: !GetAtt CharactersInPlayDynamoDBTableDataSource.Name
          RequestMappingTemplate: >
              #set( $ddb = $util.dynamodb )
              {
                  #if ($ctx.prev.result.Reactivate)
                      "version": "2018-05-29",
                      "operation": "UpdateItem",
                      "key": {
                          "CharacterId": $ddb.toDynamoDBJson($ctx.prev.result.CharacterId)
                      },
                      "update": {
                          "expression": "SET #connectionfield = :connectionId",
                          "expressionNames": {
                              "#connectionfield": "ConnectionId"
                          },
                          "expressionValues": {
                              ":connectionId": $ddb.toDynamoDBJson($ctx.prev.result.ConnectionId)
                          }
                      }
                  #else
                      "version" : "2017-02-28",
                      "operation": "PutItem",
                      "key": {
                          "CharacterId": $ddb.toDynamoDBJson($ctx.prev.result.CharacterId)
                      },
                      "attributeValues": {
                          "PlayerName": $ddb.toDynamoDBJson($ctx.prev.result.PlayerName),
                          "Name": $ddb.toDynamoDBJson($ctx.prev.result.Name),
                          "RoomId": $ddb.toDynamoDBJson($ctx.prev.result.RoomId),
                          "ConnectionId": $ddb.toDynamoDBJson($ctx.prev.result.ConnectionId)
                      }
                  #end
              }
          ResponseMappingTemplate: "$util.toJson($ctx.prev.result)"
  MutationAddCharacterInPlay:
      Type: AWS::AppSync::Resolver
      DependsOn: Schema
      Properties:
          ApiId: !GetAtt AppSyncAPI.ApiId
          TypeName: Mutation
          FieldName: addCharacterInPlay
          Kind: PIPELINE
          PipelineConfig:
              Functions:
                  - !GetAtt MutationPreQueryCharacterInPlay.FunctionId
                  - !GetAtt MutationPreQueryCharacterIfNeeded.FunctionId
                  - !GetAtt MutationAddCharacterInPlayPutFunction.FunctionId
          RequestMappingTemplate: >
              {
                  "CharacterId": $util.toJson($ctx.args.CharacterId),
                  "ConnectionId": $util.toJson($ctx.args.ConnectionId)
              }
          ResponseMappingTemplate: "$util.toJson($ctx.result)"
  MutationDeleteCharacterPreFetchFunction:
    Type: AWS::AppSync::FunctionConfiguration
    Properties:
        FunctionVersion: "2018-05-29"
        ApiId: !GetAtt AppSyncAPI.ApiId
        Name: DeleteCharacterPreFetch
        Description: Finds the CharactedId for the first CharacterInPlay record of a given ConnectionId
        DataSourceName: !GetAtt CharactersInPlayDynamoDBTableDataSource.Name
        RequestMappingTemplate: >
            {
              "version": "2017-02-28",
              "operation": "Query",
              "query": {
                  "expression": "ConnectionId = :ConnectionId",
                  "expressionValues": {
                      ":ConnectionId": $util.dynamodb.toDynamoDBJson($ctx.prev.result.ConnectionId)
                  }
              },
              "index": "ConnectionIndex"
            }
        ResponseMappingTemplate: >
            #if ($ctx.result.items)
              $util.toJson({
                "CharacterId": "$ctx.result.items[0].CharacterId"
              })
            #else
              {}
            #end
  MutationDeleteCharacterFunction:
    Type: AWS::AppSync::FunctionConfiguration
    Properties:
        FunctionVersion: "2018-05-29"
        ApiId: !GetAtt AppSyncAPI.ApiId
        Name: DeleteCharacterPreFetch
        Description: Finds the CharactedId for the first CharacterInPlay record of a given ConnectionId
        DataSourceName: !GetAtt CharactersInPlayDynamoDBTableDataSource.Name
        RequestMappingTemplate: >
            #if(!($ctx.prev.result.CharacterId))
                $util.error("CharacterId field required")
            #end
            #set( $ddb = $util.dynamodb )
            {
                "version": "2018-05-29",
                "operation": "UpdateItem",
                "key": {
                    "CharacterId": $ddb.toDynamoDBJson($ctx.prev.result.CharacterId)
                },
                "update": {
                    "expression": "REMOVE #connectionfield",
                    "expressionNames": {
                        "#connectionfield": "ConnectionId"
                    }
                }
            }
        ResponseMappingTemplate: "$util.toJson($ctx.result)"
  MutationDeleteCharacterInPlayResolver:
      Type: AWS::AppSync::Resolver
      DependsOn: Schema
      Properties:
          ApiId: !GetAtt AppSyncAPI.ApiId
          TypeName: Mutation
          FieldName: deleteCharacterInPlay
          Kind: PIPELINE
          PipelineConfig:
            Functions:
                - !GetAtt MutationDeleteCharacterPreFetchFunction.FunctionId
                - !GetAtt MutationDeleteCharacterFunction.FunctionId
          RequestMappingTemplate: >
              {
                  "ConnectionId": $util.toJson($ctx.args.ConnectionId)
              }
          ResponseMappingTemplate: "$util.toJson($ctx.result)"
  MutationMoveCharacterResolver:
      Type: AWS::AppSync::Resolver
      DependsOn: Schema
      Properties:
          ApiId: !GetAtt AppSyncAPI.ApiId
          TypeName: Mutation
          FieldName: moveCharacter
          DataSourceName: !GetAtt CharactersInPlayDynamoDBTableDataSource.Name
          RequestMappingTemplate: >
              #if(!($ctx.args.CharacterId))
                  $util.error("CharacterId field required")
              #end
              #if(!($ctx.args.RoomId))
                  $util.error("RoomId field required")
              #end
              #set( $ddb = $util.dynamodb )
              {
                  "version": "2018-05-29",
                  "operation": "UpdateItem",
                  "key": {
                      "CharacterId": $ddb.toDynamoDBJson($ctx.args.CharacterId)
                  },
                  "update": {
                      "expression": "SET #roomfield = :roomId",
                      "expressionNames": {
                          "#roomfield": "RoomId"
                      },
                      "expressionValues": {
                          ":roomId": $ddb.toDynamoDBJson($ctx.args.RoomId)
                      }
                  }
              }
          ResponseMappingTemplate: "$util.toJson($ctx.result)"
  MutationPreQueryPermanentParentFunction:
      Type: AWS::AppSync::FunctionConfiguration
      Properties:
          FunctionVersion: "2018-05-29"
          ApiId: !GetAtt AppSyncAPI.ApiId
          Name: PreQueryPermanentParent
          Description: Gets the parent node in order to construct ancestry
          DataSourceName: !GetAtt PermanentsDynamoDBTableDataSource.Name
          RequestMappingTemplate: >
              #if($util.isNullOrEmpty($ctx.prev.result.ParentId))
                  #return($ctx.prev.result)
              #end
              {
                  "version": "2017-02-28",
                  "operation": "GetItem",
                  "key": {
                      "permanentId": $util.dynamodb.toStringJson($ctx.prev.result.ParentId)
                  }
              }
          ResponseMappingTemplate: >
              #if ($ctx.error)
                  $util.error($ctx.error.message, $ctx.error.type)
              #end
              #set($prev = $ctx.prev.result)
              {
                  "Name": $util.toJson($prev.Name),
                  "PermanentId": $util.toJson($prev.PermanentId)
                  #if($util.isList($prev.Exits)), "Exits": $util.toJson($prev.Exits)#end
                  #if($util.isList($prev.Entries)), "Entries": $util.toJson($prev.Entries)#end
                  #if(!$util.isNullOrEmpty($prev.Description)), "Description": $util.toJson($prev.Description)#end
                  #if(!$util.isNullOrEmpty($prev.ParentId)), "ParentId": $util.toJson($prev.ParentId)#end
                  #if ($util.isMap($ctx.result))
                      #if (!$util.isNullOrEmpty($ctx.result.ancestry))
                          , "ParentAncestry": $util.toJson($ctx.result.ancestry)
                      #end
                  #end
              }
  MutationPutNeighborhoodFunction:
      Type: AWS::AppSync::FunctionConfiguration
      Properties:
          FunctionVersion: "2018-05-29"
          ApiId: !GetAtt AppSyncAPI.ApiId
          Name: PutNeighborhood
          Description: Puts a neighborhood into the Permanents table
          DataSourceName: !GetAtt PermanentsDynamoDBTableDataSource.Name
          RequestMappingTemplate: >
              #set( $ddb = $util.dynamodb )
              #set( $args = $ctx.prev.result )
              #set( $PermanentId = $args.PermanentId )
              #if($util.isNullOrEmpty($PermanentId))
                  #set( $PermanentId = $util.autoId() )
              #end
              #if($args.ParentAncestry)
                  #set($ancestry = "${args.ParentAncestry}:${PermanentId}")
              #else
                  #set($ancestry = $PermanentId)
              #end
              {
                  "version": "2017-02-28",
                  "operation": "PutItem",
                  "key": {
                      "permanentId": $ddb.toDynamoDBJson($PermanentId)
                  },
                  "attributeValues": {
                      "name": $ddb.toDynamoDBJson($args.Name),
                      "type": $ddb.toStringJson("NEIGHBORHOOD"),
                      "ancestry": $ddb.toStringJson($ancestry)
                      #if(!$util.isNullOrEmpty($args.Description)), "description": $ddb.toStringJson($args.Description) #end
                      #if(!$util.isNullOrEmpty($args.ParentId)), "parentId": $ddb.toStringJson($args.ParentId) #end
                  }
              }
          ResponseMappingTemplate: >
              {
                  "PermanentId": $util.toJson($ctx.result.permanentId),
                  "ParentId": $util.toJson($ctx.result.parentId),
                  "Type": "NEIGHBORHOOD",
                  "Ancestry": $util.toJson($ctx.result.ancestry),
                  "Name": $util.toJson($ctx.result.name),
                  "Description": $util.toJson($ctx.result.description)
              }
  MutationPutNeighborhood:
      Type: AWS::AppSync::Resolver
      DependsOn: Schema
      Properties:
          ApiId: !GetAtt AppSyncAPI.ApiId
          TypeName: Mutation
          FieldName: putNeighborhood
          Kind: PIPELINE
          PipelineConfig:
              Functions:
                  - !GetAtt MutationPreQueryPermanentParentFunction.FunctionId
                  - !GetAtt MutationPutNeighborhoodFunction.FunctionId
          RequestMappingTemplate: "$util.toJson($ctx.args)"
          ResponseMappingTemplate: "$util.toJson($ctx.result)"
  UUIDLambdaLayer:
      Type: AWS::Serverless::LayerVersion
      Properties:
          LayerName: uuid-layer
          Description: Lambda layer to import the uuid library
          ContentUri: lambda/uuidLayer/
          CompatibleRuntimes:
              - nodejs12.x
  PutRoomPathsFunction:
      Type: AWS::Serverless::Function
      Properties:
          CodeUri: lambda/permanents/putRoomPaths/
          Handler: app.handler
          MemorySize: 256
          Runtime: nodejs12.x
          Layers:
              - !Ref UUIDLambdaLayer
          Environment:
              Variables:
                  TABLE_PREFIX: !Ref TablePrefix
          Policies:
            - DynamoDBCrudPolicy:
                  TableName: !Sub '${TablePrefix}_permanents'
  PutRoomPermission:
      Type: AWS::Lambda::Permission
      DependsOn:
          - PutRoomPathsFunction
      Properties:
          Action: lambda:InvokeFunction
          FunctionName: !Ref PutRoomPathsFunction
          Principal: appsync.amazonaws.com
  MutationPutRoomBaseFunction:
      Type: AWS::AppSync::FunctionConfiguration
      Properties:
          FunctionVersion: "2018-05-29"
          ApiId: !GetAtt AppSyncAPI.ApiId
          Name: PutRoomBase
          Description: Puts a room record into the Permanents table
          DataSourceName: !GetAtt PermanentsDynamoDBTableDataSource.Name
          RequestMappingTemplate: >
              #set( $ddb = $util.dynamodb )
              #set( $args = $ctx.prev.result )
              #set( $PermanentId = $args.PermanentId )
              #if($util.isNullOrEmpty($PermanentId))
                  #set( $PermanentId = $util.autoId() )
              #end
              #if($args.ParentAncestry)
                  #set($ancestry = "${args.ParentAncestry}:${PermanentId}")
              #else
                  #set($ancestry = $PermanentId)
              #end
              {
                  "version": "2017-02-28",
                  "operation": "PutItem",
                  "key": {
                      "permanentId": $ddb.toDynamoDBJson($PermanentId)
                  },
                  "attributeValues": {
                      "name": $ddb.toDynamoDBJson($args.Name),
                      "type": $ddb.toStringJson("ROOM"),
                      "ancestry": $ddb.toStringJson($ancestry)
                      #if(!$util.isNullOrEmpty($args.Description)), "description": $ddb.toStringJson($args.Description) #end
                      #if(!$util.isNullOrEmpty($args.ParentId)), "parentId": $ddb.toStringJson($args.ParentId) #end
                  }
              }
          ResponseMappingTemplate: >
              #set($output = {
                  "PermanentId": $ctx.result.permanentId,
                  "Type": "ROOM",
                  "Ancestry": $ctx.result.ancestry,
                  "Name": $ctx.result.name,
                  "Exits": $ctx.prev.result.Exits,
                  "Entries": $ctx.prev.result.Entries
              })
              #if(!$util.isNullOrEmpty($ctx.prev.result.ParentId))$util.qr($output.put("ParentId", $ctx.prev.result.ParentId))#end
              #if(!$util.isNullOrEmpty($ctx.prev.result.Description))$util.qr($output.put("Description", $ctx.prev.result.Description))#end
              $util.toJson($output)
  PutRoomPathsDataSource:
      Type: AWS::AppSync::DataSource
      Properties:
          ApiId: !GetAtt AppSyncAPI.ApiId
          Name: PutRoomPath
          Type: AWS_LAMBDA
          ServiceRoleArn: !GetAtt AppSyncAPIExecutionRole.Arn
          LambdaConfig:
              LambdaFunctionArn: !GetAtt PutRoomPathsFunction.Arn
  MutationPutRoomPathsFunction:
      Type: AWS::AppSync::FunctionConfiguration
      Properties:
          FunctionVersion: "2018-05-29"
          ApiId: !GetAtt AppSyncAPI.ApiId
          Name: PutRoomPaths
          Description: Puts the needed entry records into the Permanents table
          DataSourceName: !GetAtt PutRoomPathsDataSource.Name
          RequestMappingTemplate: >
              {
                  "version": "2017-02-28",
                  "operation": "Invoke",
                  "payload": {
                      "source": {
                          "PermanentId": $util.toJson($ctx.prev.result.PermanentId),
                          "Ancestry": $util.toJson($ctx.prev.result.Ancestry)
                      },
                      "Exits": $util.toJson($ctx.prev.result.Exits),
                      "Entries": $util.toJson($ctx.prev.result.Entries)
                  }
              }
          ResponseMappingTemplate: >
              #set($output = {
                  "PermanentId": $ctx.prev.result.PermanentId,
                  "Type": "ROOM",
                  "Ancestry": $ctx.prev.result.Ancestry,
                  "Name": $ctx.prev.result.Name,
                  "Exits": $ctx.prev.result.Exits,
                  "Entries": $ctx.prev.result.Entries
              })
              #if(!$util.isNullOrEmpty($ctx.prev.result.ParentId))$util.qr($output.put("ParentId", $ctx.prev.result.ParentId))#end
              #if(!$util.isNullOrEmpty($ctx.prev.result.Description))$util.qr($output.put("Description", $ctx.prev.result.Description))#end
              $util.toJson($output)
  MutationPutRoom:
      Type: AWS::AppSync::Resolver
      DependsOn: Schema
      Properties:
          ApiId: !GetAtt AppSyncAPI.ApiId
          TypeName: Mutation
          FieldName: putRoom
          Kind: PIPELINE
          PipelineConfig:
              Functions:
                - !GetAtt MutationPreQueryPermanentParentFunction.FunctionId
                - !GetAtt MutationPutRoomBaseFunction.FunctionId
                - !GetAtt MutationPutRoomPathsFunction.FunctionId
          RequestMappingTemplate: "$util.toJson($ctx.args)"
          ResponseMappingTemplate: "$util.toJson($ctx.result)"
  MutationPutRoomMessage:
      Type: AWS::AppSync::Resolver
      DependsOn: Schema
      Properties:
        ApiId: !GetAtt AppSyncAPI.ApiId
        TypeName: Mutation
        FieldName: putRoomMessage
        DataSourceName: !GetAtt MessagesDynamoDBTableDataSource.Name
        RequestMappingTemplate: >
            #set($args = $ctx.args)
            #if($util.isNullOrEmpty($args.RoomId))
                $util.error("RoomId field required")
            #end
            #set ($MessageId = $util.defaultIfNullOrBlank($args.MessageId, $util.autoId()))
            #set ($CreatedTime = $util.defaultIfNull($args.CreatedTime, $util.time.nowEpochMilliSeconds()))
            #set ($MessageType = $util.defaultIfNullOrBlank($args.MessageType, "ROOM"))
            #set ($ExpirationTime = $util.time.nowEpochSeconds() + 600)
            #set( $ddb = $util.dynamodb )
            {
                "version": "2018-05-29",
                "operation": "PutItem",
                "key": {
                    "Target": $ddb.toDynamoDBJson("ROOM#${args.RoomId}"),
                    "DataCategory": $ddb.toDynamoDBJson("${CreatedTime}#${MessageId}")
                },
                "attributeValues": {
                    "ExpirationTime": $ddb.toNumberJson($ExpirationTime),
                    "Recap": $ddb.toBooleanJson(false),
                    "Type": $ddb.toStringJson($MessageType)
                    #if(!$util.isNullOrEmpty($args.Message)), "Message": $ddb.toStringJson($args.Message) #end
                    #if(!$util.isNullOrEmpty($args.FromCharacterId)), "FromCharacterId": $ddb.toStringJson($args.FromCharacterId) #end
                    #if(!$util.isNullOrEmpty($args.Title)), "Title": $ddb.toStringJson($args.Title) #end
                }
            }
        ResponseMappingTemplate: >
            #set($split = $ctx.result.DataCategory.split("#"))
            $util.toJson({
                "RoomId": "$ctx.args.RoomId",
                "Type": "$util.defaultIfNull($ctx.result.Type, 'ROOM')",
                "CreatedTime": "$split[0]",
                "MessageId": "$split[1]",
                "Recap": true,
                "Message": "$ctx.result.Message",
                "FromCharacterId": "$util.defaultIfNull($ctx.result.FromCharacterId, '')",
                "Title": "$util.defaultIfNull($ctx.result.Title, '')"
            })
  Schema:
      Type: AWS::AppSync::GraphQLSchema
      Properties:
          ApiId: !GetAtt AppSyncAPI.ApiId
          Definition: >
              type Player {
                  PlayerName: String!
                  CodeOfConductConsent: Boolean
              }
              type Character @aws_iam @aws_cognito_user_pools {
                  PlayerName: String!
                  Name: String!
                  CharacterId: ID!
                  Pronouns: String
                  FirstImpression: String
                  Outfit: String
                  OneCoolThing: String
                  HomeId: String
              }
              type CharacterInPlay @aws_iam @aws_cognito_user_pools {
                  CharacterId: ID!
                  Character: Character!
                  RoomId: String!
                  ConnectionId: String
              }
              interface PermanentTreeNode {
                  PermanentId: String!
                  Type: String!
                  Name: String!
                  Ancestry: String!
                  Description: String
                  ParentId: String
              }
              type Neighborhood implements PermanentTreeNode {
                  PermanentId: String!
                  Type: String!
                  Name: String!
                  Ancestry: String!
                  Description: String
                  ParentId: String
              }
              interface RoomPath {
                  PermanentId: String
                  Name: String!
                  RoomId: String
                  Ancestry: String
              }
              type Exit implements RoomPath {
                  PermanentId: String!
                  Name: String!
                  RoomId: String!
                  Ancestry: String!
              }
              type Entry implements RoomPath {
                  PermanentId: String!
                  Name: String!
                  RoomId: String!
                  Ancestry: String!
              }
              input PathInput {
                  PermanentId: String
                  Name: String!
                  RoomId: String
              }
              type Room implements PermanentTreeNode {
                  PermanentId: String!
                  Type: String!
                  Name: String!
                  Ancestry: String!
                  Description: String
                  ParentId: String
                  Exits: [Exit]
                  Entries: [Entry]
              }
              interface Message {
                  MessageId: String!
                  CreatedTime: Long!
              }
              type RoomMessage implements Message @aws_iam @aws_cognito_user_pools {
                  MessageId: String!
                  CreatedTime: Long!
                  RoomId: String!
                  Message: String!
                  FromCharacterId: String
                  Recap: Boolean
                  ExpirationTime: Long
                  Type: String
                  Title: String
              }
              type Mutation {
                  putPlayer(
                      PlayerName: String,
                      CodeOfConductConsent: Boolean
                    ): Player
                  putCharacter(
                      Name: String!,
                      CharacterId: String,
                      Pronouns: String,
                      FirstImpression: String,
                      Outfit: String,
                      OneCoolThing: String,
                      HomeId: String
                  ): Character
                  addCharacterInPlay(
                      CharacterId: String!
                      ConnectionId: String!
                  ): CharacterInPlay
                  @aws_iam @aws_cognito_user_pools
                  deleteCharacterInPlay(
                      ConnectionId: String!
                  ): CharacterInPlay
                  @aws_iam @aws_cognito_user_pools
                  moveCharacter(
                      CharacterId: String!
                      RoomId: String!
                  ): CharacterInPlay
                  putNeighborhood(
                      PermanentId: String
                      Name: String!
                      Description: String
                      ParentId: String
                  ): Neighborhood
                  putRoom(
                      PermanentId: String
                      Name: String!
                      Description: String
                      ParentId: String
                      Exits: [PathInput]
                      Entries: [PathInput]
                  ): Room
                  putRoomMessage(
                      RoomId: String!
                      Message: String!
                      MessageType: String
                      Title: String
                      FromCharacterId: String
                      MessageId: String
                      CreatedTime: Long
                  ): RoomMessage
                  @aws_iam @aws_cognito_user_pools
              }
              type Query {
                  getPlayer(PlayerName: String!): Player
                  getCharacter(playerName: String!, name: String!): Character
                  getPlayerCharacters: [Character]
                  getCharactersInPlay: [CharacterInPlay]
                  getNeighborhoodTree: [PermanentTreeNode]
                  getNeighborhood(PermanentId: String!): Neighborhood
                  getRoom(PermanentId: String!): Room
                  getRoomRecap(PermanentId: String!): [RoomMessage]
                  getRoomByCharacter(CharacterId: String!): Room
              }
              type Subscription {
                  changedPlayer (PlayerName: String): Player
                  @aws_subscribe(mutations: ["putPlayer"])
                  changedCharacter: Character
                  @aws_subscribe(mutations: ["putCharacter"])
                  changedCharactersInPlay: CharacterInPlay
                  @aws_subscribe(mutations: ["addCharacterInPlay", "deleteCharacterInPlay", "moveCharacter"])
                  changedNeighborhood: Neighborhood
                  @aws_subscribe(mutations: ["putNeighborhood"])
                  changedRoom: Room
                  @aws_subscribe(mutations: ["putRoom"])
                  addedRoomMessage (RoomId: String!): RoomMessage
                  @aws_subscribe(mutations: ["putRoomMessage"])
              }
              schema {
                  mutation: Mutation
                  query: Query
                  subscription: Subscription
              }

Outputs:
  WebSocketURI:
    Description: "The WSS Protocol URI to connect to for realtime messages"
    Value: !Join [ '', [ 'wss://', !Ref RealTimeWebSocket, '.execute-api.',!Ref 'AWS::Region','.amazonaws.com/',!Ref 'RealTimeStage'] ]

  AppSyncAPI:
    Description: The ID of the AppSync Api
    Value: !Ref AppSyncAPI